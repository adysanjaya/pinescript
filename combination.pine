//@version=6
indicator("Free Technical Indicators", overlay=true, max_boxes_count=500, max_labels_count=500, max_lines_count=500)
showOrderBlocks = input.bool(true, "Show Order Blocks Lux Algo", group="Enable Features")
showEMACross = input.bool(true, "Show EMA Cross", group="Enable Features")
showPivotPoints = input.bool(true, "Show Pivot Points", group="Enable Features")
showMoneyFlowProfile = input.bool(true, "Show Money Flow Profile", group="Enable Features")

DEFAULT_COLOR = #FB8C00
DEFAULT_COLOR_RED = #F23545
DEFAULT_COLOR_GREEN = #4CAF4F
DEFAULT_COLOR_BLUE = #2862FF

// ========== ORDER BLOCK ==========

// --- Order Block Detector Settings ---
length_ob = input.int(5, 'Volume Pivot Length', minval=1, group="Order Block Settings")
bull_ext_last = input.int(3, 'Bullish OB', minval=1, group="Order Block Settings")
bg_bull_css = input.color(color.new(#169400,80), 'Bullish OB Background', group="Order Block Settings")
bull_css = input.color(#169400, 'Bullish OB Border', group="Order Block Settings")
bull_avg_css = input.color(color.new(#9598a1,37), 'Bullish OB Average Line', group="Order Block Settings")
bear_ext_last = input.int(3, 'Bearish OB', minval=1, group="Order Block Settings")
bg_bear_css = input.color(color.new(#ff1100,80), 'Bearish OB Background', group="Order Block Settings")
bear_css = input.color(#ff1100, 'Bearish OB Border', group="Order Block Settings")
bear_avg_css = input.color(color.new(#9598a1,37), 'Bearish OB Average Line', group="Order Block Settings")
line_style = input.string('⎯⎯⎯', 'Average Line Style', options=['⎯⎯⎯','----','····'], group="Order Block Settings")
line_width = input.int(1, 'Average Line Width', minval=1, group="Order Block Settings")
mitigation = input.string('Wick', 'Mitigation Methods', options=['Wick','Close'], group="Order Block Settings")

// --- EMA Cross Settings ---
len13 = input.int(13, minval=1, title="EMA 13 Length", group="EMA Settings")
src13 = input(close, title="EMA 13 Source", group="EMA Settings")
offset13 = input.int(title="EMA 13 Offset", defval=0, minval=-500, maxval=500, group="EMA Settings", display=display.data_window)
len21 = input.int(21, minval=1, title="EMA 21 Length", group="EMA Settings")
src21 = input(close, title="EMA 21 Source", group="EMA Settings")
offset21 = input.int(title="EMA 21 Offset", defval=0, minval=-500, maxval=500, group="EMA Settings", display=display.data_window)

// --- Smoothing MA Settings ---
GRP = "Smoothing MA Settings"
TT_BB = "Only applies when 'SMA + Bollinger Bands' is selected. Determines the distance between the SMA and the bands."
maTypeInput = input.string("None", "Type", options=["None", "SMA", "SMA + Bollinger Bands", "EMA", "SMMA (RMA)", "WMA", "VWMA"], group=GRP, display=display.data_window)
maLengthInput = input.int(14, "Length", group=GRP, display=display.data_window)
bbMultInput = input.float(2.0, "BB StdDev", minval=0.001, maxval=50, step=0.5, tooltip=TT_BB, group=GRP, display=display.data_window)
var enableMA = maTypeInput != "None"
var isBB = maTypeInput == "SMA + Bollinger Bands"

// --- Functions ---

// Order Block: Line Style
get_line_style(style) =>
    switch style
        '⎯⎯⎯' => line.style_solid
        '----' => line.style_dashed
        '····' => line.style_dotted

// Order Block: Get Coordinates
get_coordinates(condition, top, btm, ob_val) =>
    var array<float> ob_top = array.new_float()
    var array<float> ob_btm = array.new_float()
    var array<float> ob_avg = array.new_float()
    var array<int> ob_left = array.new_int()
    float ob = na
    if bool(condition)
        avg = math.avg(top, btm)
        array.unshift(ob_top, top)
        array.unshift(ob_btm, btm)
        array.unshift(ob_avg, avg)
        array.unshift(ob_left, time[length_ob])
        ob := ob_val
    [ob_top, ob_btm, ob_avg, ob_left, ob]

// Order Block: Remove Mitigated
remove_mitigated(ob_top, ob_btm, ob_left, ob_avg, target, bool bull) =>
    bool mitigated = false
    array<float> target_array = bull ? ob_btm : ob_top
    for element in target_array
        idx = array.indexof(target_array, element)
        if bull ? (target < element) : (target > element)
            mitigated := true
            array.remove(ob_top, idx)
            array.remove(ob_btm, idx)
            array.remove(ob_avg, idx)
            array.remove(ob_left, idx)
    mitigated

// Order Block: Set Order Blocks
set_order_blocks(ob_top, ob_btm, ob_left, ob_avg, ext_last, bg_css, border_css, lvl_css) =>
    var array<box> ob_box = array.new_box()
    var array<line> ob_lvl = array.new_line()
    if barstate.isfirst
        for i = 0 to ext_last - 1
            array.unshift(ob_box, box.new(na, na, na, na, xloc=xloc.bar_time, extend=extend.right, bgcolor=bg_css, border_color=color.new(border_css,70)))
            array.unshift(ob_lvl, line.new(na, na, na, na, xloc=xloc.bar_time, extend=extend.right, color=lvl_css, style=get_line_style(line_style), width=line_width))
    if barstate.islast
        if array.size(ob_top) > 0
            for i = 0 to math.min(ext_last - 1, array.size(ob_top) - 1)
                b = array.get(ob_box, i)
                l = array.get(ob_lvl, i)
                box.set_lefttop(b, array.get(ob_left, i), array.get(ob_top, i))
                box.set_rightbottom(b, array.get(ob_left, i), array.get(ob_btm, i))
                line.set_xy1(l, array.get(ob_left, i), array.get(ob_avg, i))
                line.set_xy2(l, array.get(ob_left, i) + 1, array.get(ob_avg, i))

// Smoothing MA Calculation
ma(source, length, MAtype) =>
    switch MAtype
        "SMA"                   => ta.sma(source, length)
        "SMA + Bollinger Bands" => ta.sma(source, length)
        "EMA"                   => ta.ema(source, length)
        "SMMA (RMA)"            => ta.rma(source, length)
        "WMA"                   => ta.wma(source, length)
        "VWMA"                  => ta.vwma(source, length)

// --- Order Block Calculations ---
var int os = 0
var float target_bull = na
var float target_bear = na

n = bar_index
upper = ta.highest(length_ob)
lower = ta.lowest(length_ob)

target_bull := mitigation == 'Close' ? ta.lowest(close, length_ob) : lower
target_bear := mitigation == 'Close' ? ta.highest(close, length_ob) : upper

os := high[length_ob] > upper ? 0 : low[length_ob] < lower ? 1 : os[1]

phv = ta.pivothigh(volume, length_ob, length_ob)
cond_bull = not na(phv) and os == 1
cond_bear = not na(phv) and os == 0

[bull_top, bull_btm, bull_avg, bull_left, bull_ob] = get_coordinates(cond_bull, hl2[length_ob], low[length_ob], low[length_ob])
[bear_top, bear_btm, bear_avg, bear_left, bear_ob] = get_coordinates(cond_bear, high[length_ob], hl2[length_ob], high[length_ob])

// Remove Mitigated Order Blocks
mitigated_bull = remove_mitigated(bull_top, bull_btm, bull_left, bull_avg, target_bull, true)
mitigated_bear = remove_mitigated(bear_top, bear_btm, bear_left, bear_avg, target_bear, false)

// --- EMA Calculations ---
out13 = ta.ema(src13, len13)
out21 = ta.ema(src21, len21)

// Smoothing MA Calculations
smoothingMA13 = enableMA ? ma(out13, maLengthInput, maTypeInput) : na
smoothingStDev13 = isBB ? ta.stdev(out13, maLengthInput) * bbMultInput : na
smoothingMA21 = enableMA ? ma(out21, maLengthInput, maTypeInput) : na
smoothingStDev21 = isBB ? ta.stdev(out21, maLengthInput) * bbMultInput : na

// --- Display ---

// Order Blocks
if showOrderBlocks
    set_order_blocks(bull_top, bull_btm, bull_left, bull_avg, bull_ext_last, bg_bull_css, bull_css, bull_avg_css)
    set_order_blocks(bear_top, bear_btm, bear_left, bear_avg, bear_ext_last, bg_bear_css, bear_css, bear_avg_css)

plot(bull_ob, 'Bull OB', bull_css, 2, plot.style_linebr, offset=-length_ob, display=display.none)
plot(bear_ob, 'Bear OB', bear_css, 2, plot.style_linebr, offset=-length_ob, display=display.none)

// EMA Plots
plot(showEMACross ? out13 : na, title="EMA 13", color=color.green, offset=offset13)
plot(showEMACross ? out21 : na, title="EMA 21", color=color.red, offset=offset21)
plot(showEMACross ? ta.cross(out13, out21) ? out13 : na : na, color=color.new(color.blue, 0), style=plot.style_cross, linewidth=4, title="EMA Cross")

// Smoothing MA Plots for EMA 13
plot(showEMACross ? smoothingMA13 : na, "EMA 13-based MA", color=color.yellow, display=enableMA ? display.all : display.none, editable=enableMA)
bbUpperBand13 = plot(showEMACross ? smoothingMA13 + smoothingStDev13 : na, title="EMA 13 Upper Bollinger Band", color=color.green, display=isBB ? display.all : display.none, editable=isBB)
bbLowerBand13 = plot(showEMACross ? smoothingMA13 - smoothingStDev13 : na, title="EMA 13 Lower Bollinger Band", color=color.green, display=isBB ? display.all : display.none, editable=isBB)
fill(bbUpperBand13, bbLowerBand13, color=isBB ? color.new(color.green, 90) : na, title="EMA 13 Bollinger Bands Background Fill", display=isBB ? display.all : display.none, editable=isBB)

// Smoothing MA Plots for EMA 21
plot(showEMACross ? smoothingMA21 : na, "EMA 21-based MA", color=color.orange, display=enableMA ? display.all : display.none, editable=enableMA)
bbUpperBand21 = plot(showEMACross ? smoothingMA21 + smoothingStDev21 : na, title="EMA 21 Upper Bollinger Band", color=color.purple, display=isBB ? display.all : display.none, editable=isBB)
bbLowerBand21 = plot(showEMACross ? smoothingMA21 - smoothingStDev21 : na, title="EMA 21 Lower Bollinger Band", color=color.purple, display=isBB ? display.all : display.none, editable=isBB)
fill(bbUpperBand21, bbLowerBand21, color=isBB ? color.new(color.purple, 90) : na, title="EMA 21 Bollinger Bands Background Fill", display=isBB ? display.all : display.none, editable=isBB)

// --- Alerts ---
alertcondition(bool(bull_ob), 'Bullish OB Formed', 'Bullish order block detected')
alertcondition(bool(bear_ob), 'Bearish OB Formed', 'Bearish order block detected')
alertcondition(mitigated_bull, 'Bullish OB Mitigated', 'Bullish order block mitigated')
alertcondition(mitigated_bear, 'Bearish OB Mitigated', 'Bearish order block mitigated')
alertcondition(ta.crossover(out13, out21), 'EMA 13 Cross Above EMA 21', 'EMA 13 crossed above EMA 21')
alertcondition(ta.crossunder(out13, out21), 'EMA 13 Cross Below EMA 21', 'EMA 13 crossed below EMA 21')

// ========== PIVOT POINTS START ==========
//@variable reused to prevent conflict
var FIRST_BAR_TIME_PIVOT = time

pivotTypeInput = input.string(title="Type", defval="Traditional", options=["Traditional", "Fibonacci", "Woodie", "Classic", "DM", "Camarilla"])
pivotAnchorInput = input.string(title="Pivots Timeframe", defval="Auto", options=["Auto", "Daily", "Weekly", "Monthly", "Quarterly", "Yearly", "Biyearly", "Triyearly", "Quinquennially", "Decennially"])
maxHistoricalPivotsInput = input.int(title="Number of Pivots Back", defval=15, minval=1, maxval=200, display = display.data_window)
isDailyBasedInput = input.bool(title="Use Daily-based Values", defval=true, display = display.data_window, tooltip="When this option is unchecked, Pivot Points will use intraday data while calculating on intraday charts. If Extended Hours are displayed on the chart, they will be taken into account during the pivot level calculation. If intraday OHLC values are different from daily-based values (normal for stocks), the pivot levels will also differ.")
showLabelsInput = input.bool(title="Show Labels", defval=true, group="labels", display = display.data_window)
showPricesInput = input.bool(title="Show Prices", defval=true, group="labels", display = display.data_window)
positionLabelsInput = input.string("Left", "Labels Position", options=["Left", "Right"], group="labels", display = display.data_window)
linewidthInput = input.int(title="Line Width", defval=1, minval=1, maxval=100, group="levels", display = display.data_window)


pColorInput = input.color(DEFAULT_COLOR_BLUE, "P‏  ‏  ‏", inline="P", group="levels", display = display.data_window)
pShowInput = input.bool(true, "", inline="P", group="levels", display = display.data_window)
s1ColorInput = input.color(DEFAULT_COLOR_GREEN, "S1", inline="S1/R1" , group="levels", display = display.data_window)
s1ShowInput = input.bool(true, "", inline="S1/R1", group="levels", display = display.data_window)
r1ColorInput = input.color(DEFAULT_COLOR_RED, "‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏R1", inline="S1/R1", group="levels", display = display.data_window)
r1ShowInput = input.bool(true, "", inline="S1/R1", group="levels", display = display.data_window)
s2ColorInput = input.color(DEFAULT_COLOR_GREEN, "S2", inline="S2/R2", group="levels", display = display.data_window)
s2ShowInput = input.bool(true, "", inline="S2/R2", group="levels", display = display.data_window)
r2ColorInput = input.color(DEFAULT_COLOR_RED, "‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏R2", inline="S2/R2", group="levels", display = display.data_window)
r2ShowInput = input.bool(true, "", inline="S2/R2", group="levels", tooltip = "Not applicable to DM", display = display.data_window)
s3ColorInput = input.color(DEFAULT_COLOR_GREEN, "S3", inline="S3/R3", group="levels", display = display.data_window)
s3ShowInput = input.bool(false, "", inline="S3/R3", group="levels", display = display.data_window)
r3ColorInput = input.color(DEFAULT_COLOR_RED, "‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏R3", inline="S3/R3", group="levels", display = display.data_window)
r3ShowInput = input.bool(true, "", inline="S3/R3", group="levels", tooltip = "Not applicable to DM", display = display.data_window)
s4ColorInput = input.color(DEFAULT_COLOR_GREEN, "S4", inline="S4/R4", group="levels", display = display.data_window)
s4ShowInput = input.bool(false, "", inline="S4/R4", group="levels", display = display.data_window)
r4ColorInput = input.color(DEFAULT_COLOR_RED, "‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏R4", inline="S4/R4", group="levels", display = display.data_window)
r4ShowInput = input.bool(false, "", inline="S4/R4", group="levels", tooltip = "Not applicable to: Fibonacci, DM", display = display.data_window)
s5ColorInput = input.color(DEFAULT_COLOR_GREEN, "S5", inline="S5/R5", group="levels", display = display.data_window)
s5ShowInput = input.bool(false, "", inline="S5/R5", group="levels", display = display.data_window)
r5ColorInput = input.color(DEFAULT_COLOR_RED, "‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏R5", inline="S5/R5", group="levels", display = display.data_window)
r5ShowInput = input.bool(false, "", inline="S5/R5", group="levels", tooltip = "Not applicable to: Fibonacci, Woodie, Classic, DM", display = display.data_window)

type graphicSettings
    string levelName
    color levelColor
    bool showLevel

var graphicSettingsArray = array.from(
      graphicSettings.new(" P", pColorInput, pShowInput),
      graphicSettings.new("R1", r1ColorInput, r1ShowInput), graphicSettings.new("S1", s1ColorInput, s1ShowInput),
      graphicSettings.new("R2", r2ColorInput, r2ShowInput), graphicSettings.new("S2", s2ColorInput, s2ShowInput),
      graphicSettings.new("R3", r3ColorInput, r3ShowInput), graphicSettings.new("S3", s3ColorInput, s3ShowInput),
      graphicSettings.new("R4", r4ColorInput, r4ShowInput), graphicSettings.new("S4", s4ColorInput, s4ShowInput),
      graphicSettings.new("R5", r5ColorInput, r5ShowInput), graphicSettings.new("S5", s5ColorInput, s5ShowInput))

autoAnchor = switch
    timeframe.isintraday => timeframe.multiplier <= 15 ? "1D" : "1W"
    timeframe.isdaily    => "1M"
    => "12M"

pivotTimeframe = switch pivotAnchorInput
    "Auto"      => autoAnchor
    "Daily"     => "1D"
    "Weekly"    => "1W"
    "Monthly"   => "1M"
    "Quarterly" => "3M"
    => "12M"

//@variable The number of years in the selected Pivot period
pivotYearMultiplier = switch pivotAnchorInput
    "Biyearly"       => 2
    "Triyearly"      => 3
    "Quinquennially" => 5
    "Decennially"    => 10
    => 1

//@variable The number of values in the pivots of the selected type
numOfPivotLevels = switch pivotTypeInput
    "Traditional" => 11
    "Camarilla"   => 11
    "Woodie"      => 9
    "Classic"     => 9
    "Fibonacci"   => 7
    "DM"          => 3

type pivotGraphic
    line pivotLine
    label pivotLabel

method delete(pivotGraphic graphic) =>
    graphic.pivotLine.delete()
    graphic.pivotLabel.delete()

var drawnGraphics = matrix.new<pivotGraphic>()

localPivotTimeframeChange = timeframe.change(pivotTimeframe) and year % pivotYearMultiplier == 0
securityPivotTimeframeChange = timeframe.change(timeframe.period) and year % pivotYearMultiplier == 0

pivotTimeframeChangeCounter(condition) => 
    var count = 0
    if condition and bar_index > 0
        count += 1
    count

localPivots = ta.pivot_point_levels(pivotTypeInput, localPivotTimeframeChange)
securityPivotPointsArray = ta.pivot_point_levels(pivotTypeInput, securityPivotTimeframeChange)

securityTimeframe = timeframe.isintraday ? "1D" : timeframe.period
[securityPivots, securityPivotCounter] = request.security(syminfo.tickerid, pivotTimeframe, [securityPivotPointsArray, pivotTimeframeChangeCounter(securityPivotTimeframeChange)], lookahead = barmerge.lookahead_on)
pivotPointsArray = isDailyBasedInput ? securityPivots : localPivots

//@function Sets the ending points of the currently active pivots to `endTime`.
affixOldPivots(endTime) =>
    if drawnGraphics.rows() > 0
        lastGraphics = drawnGraphics.row(drawnGraphics.rows() - 1)

        for graphic in lastGraphics
            graphic.pivotLine.set_x2(endTime)
            if positionLabelsInput == "Right"
                graphic.pivotLabel.set_x(endTime)

//@function Draws pivot lines and labels from `startTime` to the approximate end of the period.
drawNewPivots(startTime) =>
    
    newGraphics = array.new<pivotGraphic>()

    for [index, coord] in pivotPointsArray
        levelSettings = graphicSettingsArray.get(index)
        if not na(coord) and levelSettings.showLevel
            lineEndTime = startTime + timeframe.in_seconds(pivotTimeframe) * 1000 * pivotYearMultiplier
            pivotLine = line.new(startTime, coord, lineEndTime, coord, xloc = xloc.bar_time, color=levelSettings.levelColor, width=linewidthInput)
            pivotLabel = label.new(x = positionLabelsInput == "Left" ? startTime : lineEndTime,
                               y = coord,
                               text = (showLabelsInput ? levelSettings.levelName + " " : "") + (showPricesInput ? "(" + str.tostring(coord, format.mintick) + ")" : ""),
                               style = positionLabelsInput == "Left" ? label.style_label_right : label.style_label_left,
                               textcolor = levelSettings.levelColor,
                               color = #00000000,
                               xloc=xloc.bar_time)
            
            newGraphics.push(pivotGraphic.new(pivotLine, pivotLabel))
    
    drawnGraphics.add_row(array_id = newGraphics)

    if drawnGraphics.rows() > maxHistoricalPivotsInput
        oldGraphics = drawnGraphics.remove_row(0)
        
        for graphic in oldGraphics
            graphic.delete()


localPivotDrawConditionStatic = not isDailyBasedInput and localPivotTimeframeChange
securityPivotDrawConditionStatic = isDailyBasedInput and securityPivotCounter != securityPivotCounter[1]

var isMultiYearly = array.from("Biyearly", "Triyearly", "Quinquennially", "Decennially").includes(pivotAnchorInput)
localPivotDrawConditionDeveloping = not isDailyBasedInput and time_close == time_close(pivotTimeframe) and not isMultiYearly 
securityPivotDrawConditionDeveloping = false

if showPivotPoints
    if (securityPivotDrawConditionStatic or localPivotDrawConditionStatic)
        affixOldPivots(time)
        drawNewPivots(time)

    // If possible, draw pivots from the beginning of the chart if none were found
    var FIRST_BAR_TIME = time
    if (barstate.islastconfirmedhistory and drawnGraphics.columns() == 0)

        if not na(securityPivots) and securityPivotCounter > 0
            if isDailyBasedInput
                drawNewPivots(FIRST_BAR_TIME)
            else 
                runtime.error("Not enough intraday data to calculate Pivot Points. Lower the Pivots Timeframe or turn on the 'Use Daily-based Values' option in the indicator settings.")
        else
            runtime.error("Not enough data to calculate Pivot Points. Lower the Pivots Timeframe in the indicator settings.")


//---------------------------------------------------------------------------------------------------------------------}
// Settings
//---------------------------------------------------------------------------------------------------------------------}

disp   = display.all - display.status_line

rpGR   = 'Profile Generic Settings'
rpLN   = input.int(200, 'Lookback Length / Fixed Range', minval = 10, maxval = 1500, step = 10 , group = rpGR, display = disp)
rpLN  := last_bar_index > rpLN ? rpLN - 1 : last_bar_index
vpSRC  = input.string('Volume', 'Profile Source', options = ['Volume', 'Money Flow'], group = rpGR, display = disp)

vpGR   = 'Profile Presentation Settings'
vpTP   = 'displays total trading activity/money flow (common interest, both buying and selling trading activity/money flow) over a specified time period at specific price levels\n\n - high traded node rows : high trading activity/money flow price levels - usually represents consolidation levels (value areas)\n - average traded node rows : average trading activity/money flow price levels\n - low traded node rows : low trading activity/money flow price levels - usually represents supply & demand levels or liquidity levels\n\n row lengths, indicates the amount of the traded activity/money flow at specific price levels'
vpSH   = input.bool(true, 'Volume/Money Flow Profile', group = vpGR, tooltip = vpTP, display = disp)
vpHVC  = input.color(color.new(#ffeb3b, 50), 'High Traded Nodes', inline = 'VP1', group = vpGR)
vpHVT  = input.int(53, 'Threshold %' , minval = 50, maxval = 99 , step = 1,inline = 'VP1', group = vpGR, tooltip = 'option range [50-99]', display = disp) / 100
vpAVC  = input.color(color.new(#2962ff, 50), 'Average Traded Nodes', group = vpGR)
vpLVC  = input.color(color.new(#f23645, 50), 'Low Traded Nodes', inline = 'VP2', group = vpGR)
vpLVT  = input.int(37, 'Threshold %' , minval = 10, maxval = 40 , step = 1,inline = 'VP2', group = vpGR, tooltip = 'option range [10-40]', display = disp) / 100

spTP   = 'displays the sentiment, the dominat party over a specified time period at the specific price levels\n\n - bullish node rows : buying trading activity/money flow is higher\n - barish node rows : selling trading activity/money flow is higher\n\nrow lengths, indicates the strength of the buyers/sellers at the specific price levels'
spSH   = input.bool(true, 'Sentiment Profile', group = vpGR, tooltip = spTP)
spPTT  = 'conditions used to calculate the up/down volume/money flow\n\n* bar polarity\n   up => if close > open\n   down => if close <= open\n\n* bar buying/selling pressure\n   up => if (close - low) > (high - close)\n   down => if (close - low) <= (high - close)'
spPT1  = 'Bar Polarity'
spPT2  = 'Bar Buying/Selling Pressure'
spPTY  = input.string(spPT1, 'Sentiment Polarity Method', options = [spPT1, spPT2], group = vpGR, tooltip = spPTT, display = disp)

spBLC  = input.color(color.new(#26a69a, 50), 'Bullish Nodes', inline = 'SP', group = vpGR)
spBRC  = input.color(color.new(#ef5350, 50), 'Bearish Nodes', inline = 'SP', group = vpGR)

hmSH   = input.bool(false, 'Profile Heatmap', group = vpGR, tooltip = 'tip : higher number of rows results with a better visuals')
hmSO1  = 'Volume/Money Flow Profile'
hmSRC  = input.string(hmSO1, 'Heatmap Source', options = [hmSO1, 'Sentiment Profile'], group = vpGR, display = disp)
hmTR   = input.int(73, 'Heatmap Transparency' , minval = 0, maxval = 100 , group = vpGR, display = disp)

othGR  = 'Other Presentation Settings'

pcTP   = 'displays the price level of the highest traded activity/money flow or the changes of the price levels with the highest traded activity/money flow'
rpPC   = input.string('Last(Zone)', 'Level of Significance', options = ['Developing', 'Last(Line)', 'Last(Zone)', 'None'], inline='PoC', group = othGR, tooltip = pcTP, display = disp)

vaSH   = input.bool(false, 'Consolidation Zones', group = othGR, display = disp)
vaTH   = input.int(25, 'Consolidation Threshold %' , minval = 0, maxval = 100, inline = 'va', group = othGR, display = disp) / 100
vaC    = input.color(color.new(#2962ff, 73), '', inline = 'va', group = othGR)

spTT   = 'displays the price zone of the highest bullish or bearish sentiment zone'
spPC   = input.bool(false, 'Highest Sentiment Zone', inline = 'spP', group = othGR, tooltip = spTT)

rpPL   = input.bool(false, 'Profile Price Levels', inline = 'BBe', group = othGR)
rpPLC  = input.color(color.new(#00bcd4, 0), '', inline = 'BBe', group = othGR)
rpLS   = input.string('Small', "", options=['Tiny', 'Small', 'Normal'], inline = 'BBe', group = othGR, display = disp)

rpBG   = input.bool(false, 'Profile Range Background Fill', inline = 'BG', group = othGR)
rpBGC  = input.color(color.new(#00bcd4, 95), '', inline = 'BG', group = othGR)

otGR   = 'Other Profile Settings'

rpNR   = input.int(25, 'Number of Rows' , minval = 10, maxval = 100 ,step = 5, group = otGR, tooltip = 'option range [10-100]', display = disp)
rpW    = input.int(13, 'Profile Width %', minval = 10, maxval = 50, group = otGR, tooltip = 'option range [10-50]', display = disp) / 100
vpLS   = input.string('Auto', "Profile Text Size", options=['Auto', 'Tiny', 'Small'], group = otGR, display = disp)
vpHO   = input.int(13, 'Profile Horizontal Offset', group = otGR, tooltip = 'option allows negative numbers as well, in case of a use the profiles will overlap with the price chart', display = disp)

//---------------------------------------------------------------------------------------------------------------------}
// User Defined Types
//---------------------------------------------------------------------------------------------------------------------}

// @type        bar properties with their values
//
// @field o     (float) open price of the bar
// @field h     (float) high price of the bar
// @field l     (float) low price of the bar
// @field c     (float) close price of the bar
// @field v     (float) volume of the bar
// @field i     (int) index of the bar

type bar
    float o = open
    float h = high
    float l = low
    float c = close
    float v = volume
    int   i = bar_index

//---------------------------------------------------------------------------------------------------------------------}
// Variables
//---------------------------------------------------------------------------------------------------------------------}

bar b = bar.new()

rpVST = array.new_float(rpNR, 0.)
rpVSB = array.new_float(rpNR, 0.)
rpVSD = array.new_float(rpNR, 0.)

var dRP = array.new_box()
var pocPoints = array.new<chart.point>()
var polyline pocPolyline = na
var polyline spPolyline = na

var color llC = na
var color lsC = na

//---------------------------------------------------------------------------------------------------------------------}
// Functions/Methods
//---------------------------------------------------------------------------------------------------------------------}

// @function        creates new label object and updates existing label objects
//
// @param           details in Pine Script™ language reference manual
//
// @returns         none, updated visual objects (labels)

f_drawLabelX(_x, _y, _text, _style, _textcolor, _size, _tooltip) =>
    var lb = label.new(_x, _y, _text, xloc.bar_index, yloc.price, color(na), _style, _textcolor, _size, text.align_left, _tooltip)
    lb.set_xy(_x, _y)
    lb.set_text(_text)
    lb.set_tooltip(_tooltip)
    lb.set_textcolor(_textcolor)

// @function    This function converts string to enumerated size
//
// @param _t    [string]    custom string
//
// @returns     [string]    enumerated size

f_gTS(_t) =>
    switch _t
        'Tiny'   => size.tiny
        'Small'  => size.small
        'Normal' => size.normal
        'Auto'   => size.auto

//---------------------------------------------------------------------------------------------------------------------}
// Calculations
//---------------------------------------------------------------------------------------------------------------------}

bull = spPTY == spPT1 ? (b[0]).c > (b[0]).o : ((b[0]).c - (b[0]).l) > ((b[0]).h - (b[0]).c)
nzV  = nz((b[0]).v)
rpS  = f_gTS(rpLS)
vpS  = f_gTS(vpLS)

var float pLST = na
var float pHST = na

if (b[0]).i == last_bar_index - rpLN
    pLST := (b[0]).l
    pHST := (b[0]).h
else if (b[0]).i > last_bar_index - rpLN
    pLST := math.min((b[0]).l, pLST)
    pHST := math.max((b[0]).h, pHST)

pSTP = (pHST - pLST) / rpNR

if showMoneyFlowProfile
    if barstate.islast and not na(nzV) and not timeframe.isseconds and rpLN > 0 and pSTP > 0 and nzV > 0

        if dRP.size() > 0
            for i = 0 to dRP.size() - 1
                box.delete(dRP.shift())

        if pocPoints.size() > 0
            pocPoints.clear()

        a_allPolylines = polyline.all
        if array.size(a_allPolylines) > 0
            for i = 0 to array.size(a_allPolylines) - 1
                polyline.delete(a_allPolylines.get(i))

        for bI = rpLN to 0
            l = 0
            for pLL = pLST to pHST - pSTP by pSTP
                if (b[bI]).h >= pLL and (b[bI]).l < pLL + pSTP

                    vPOR = if (b[bI]).l >= pLL and (b[bI]).h > pLL + pSTP
                        (pLL + pSTP - (b[bI]).l) / ((b[bI]).h - (b[bI]).l)
                    else if (b[bI]).h <= pLL + pSTP and (b[bI]).l < pLL
                        ((b[bI]).h - pLL) / ((b[bI]).h - (b[bI]).l)
                    else if ((b[bI]).l >= pLL and (b[bI]).h <= pLL + pSTP)
                        1
                    else
                        pSTP / ((b[bI]).h - (b[bI]).l)

                    if vpSRC == 'Money Flow'
                        rpVST.set(l, rpVST.get(l) + nz((b[bI]).v) * vPOR * (pLST + (l + .5) * pSTP) )
                    else
                        rpVST.set(l, rpVST.get(l) + nz((b[bI]).v) * vPOR )

                    if bull[bI] and spSH
                        if vpSRC == 'Money Flow'
                            rpVSB.set(l, rpVSB.get(l) + nz((b[bI]).v) * vPOR * (pLST + (l + .5) * pSTP))
                        else
                            rpVSB.set(l, rpVSB.get(l) + nz((b[bI]).v) * vPOR )
                l += 1

            if rpPC == 'Developing'
                if bI == rpLN
                    pocPoints.push(chart.point.from_index((b[bI]).i, pLST + (rpVST.indexof(rpVST.max()) + .5) * pSTP))
                else
                    pocPoints.push(chart.point.from_index((b[bI]).i, pLST + (rpVST.indexof(rpVST.max()) + .5) * pSTP))

        if rpPC == 'Developing'
            pocPolyline := polyline.new(pocPoints, false, false, xloc.bar_index, vpHVC, color(na), line.style_solid, 2)

        if rpPC == 'Last(Zone)' or rpPC == 'Last(Line)'
            pocPoints.push(chart.point.from_index((b[rpLN]).i, pLST + (rpVST.indexof(rpVST.max()) + .5) * pSTP))
            pocPoints.push(chart.point.from_index((b[0]).i, pLST + (rpVST.indexof(rpVST.max()) + .5) * pSTP))

            pocPolyline := polyline.new(pocPoints, false, false, xloc.bar_index, vpHVC, color(na), rpPC == 'Last(Line)' ? line.style_solid : line.style_dotted, rpPC == 'Last(Line)' ? 2 : 1)

        for l = 0 to rpNR - 1
            bbp  = 2 * rpVSB.get(l) - rpVST.get(l)
            rpVSD.set(l, rpVSD.get(l) + bbp * (bbp > 0 ? 1 : -1) )

            if vpSH or spSH
                sBI = (b[0]).i + (spSH ? rpLN * rpW : 7) + int(rpLN * rpW / 3)
                dRP.push(box.new(sBI - 1 + vpHO, pLST + (l + .1) * pSTP, sBI - int(rpLN * rpW / 3) + 1 + vpHO, pLST + (l + .9) * pSTP, #2962ff80, bgcolor = #2962ff10,text = str.tostring(pLST + (l + .5) * pSTP, format.mintick), text_color = chart.fg_color, text_size = vpS ))

        if rpBG
            dRP.push(box.new((b[0]).i - rpLN, pLST, (b[0]).i, pHST, rpBGC, bgcolor = rpBGC ))

        if rpPL
            f_drawLabelX((b[0]).i, pHST, str.tostring(pHST, format.mintick), label.style_label_down, rpPLC, rpS, 'Profile High - ' + str.tostring(pHST, format.mintick) + '\n %' + str.tostring((pHST - pLST) / pLST * 100, '#.##') + ' higher than the Profile Low\n\n' + 'Total ' + (vpSRC == 'Volume' ? 'Volume : ' : 'Money Flow (' + syminfo.currency + ') : ') + str.tostring(rpVST.sum(), format.volume) + '\nNumber of bars : ' + str.tostring(rpLN + 1))

            f_drawLabelX((b[0]).i, pLST, str.tostring(pLST, format.mintick), label.style_label_up  , rpPLC, rpS, 'Profile Low - '  + str.tostring(pLST, format.mintick) + '\n %' + str.tostring((pHST - pLST) / pHST * 100, '#.##') + ' lower than the Profile High\n\n' + 'Total ' + (vpSRC == 'Volume' ? 'Volume : ' : 'Money Flow (' + syminfo.currency + ') : ') + str.tostring(rpVST.sum(), format.volume) + '\nNumber of bars : ' + str.tostring(rpLN + 1))

        for l = 0 to rpNR - 1
            if dRP.size() < 500
                vtLV = rpVST.get(l)
                vtMX = rpVST.max()
                LpM  = vtLV / vtMX
                vdMX = rpVSD.max()
                DpM  = rpVSD.get(l) / vdMX

                llC := LpM > vpHVT ? color.from_gradient(LpM, vpHVT, 1, vpAVC, vpHVC) : color.from_gradient(LpM, 0, vpLVT, vpLVC, vpAVC)

                bbp = 2 * rpVSB.get(l) - vtLV
                lsC := bbp > 0 ? color.from_gradient(DpM, 0, .7, color.new(spBLC, 70 + int(hmTR / 4)), color.new(spBLC, 30 + int(hmTR / 4))) : color.from_gradient(DpM, 0, .7, color.new(spBRC, 70 + int(hmTR / 4)), color.new(spBRC, 30 + int(hmTR / 4)))

                if rpPC == 'Last(Zone)' and LpM == 1
                    dRP.push(box.new((b[rpLN]).i, pLST + (rpVST.indexof(vtMX) + .0) * pSTP, (b[0]).i, pLST + (rpVST.indexof(vtMX) + 1.) * pSTP, vpHVC, bgcolor = color.new(vpHVC, 73) ))

                if vaSH and LpM > vaTH and LpM < 1
                    dRP.push(box.new((b[rpLN]).i, pLST + (l + .0) * pSTP, (b[0]).i, pLST + (l + 1.) * pSTP, color(na), bgcolor = vaC ))

                if vaSH and rpPC != 'Last(Zone)' and LpM == 1
                    dRP.push(box.new((b[rpLN]).i, pLST + (l + .0) * pSTP, (b[0]).i, pLST + (l + 1.) * pSTP, color(na), bgcolor = vaC ))

                if spPC and DpM == 1
                    spPolyline := polyline.new(array.from(chart.point.from_index((b[rpLN]).i, pLST + (rpVSD.indexof(vdMX) + .5) * pSTP), chart.point.from_index((b[0]).i, pLST + (rpVSD.indexof(vdMX) + .5) * pSTP)), false, false, xloc.bar_index, lsC, color(na), line.style_dotted, 1)

                    dRP.push(box.new((b[rpLN]).i, pLST + (rpVSD.indexof(vdMX) + .0) * pSTP, (b[0]).i, pLST + (rpVSD.indexof(vdMX) + 1.) * pSTP, lsC, bgcolor = color.new(lsC, 73) ))

                if vpSH
                    sBI  = (b[0]).i + (spSH ? rpLN * rpW : 7) + int(rpLN * rpW / 3)
                    eBI  = sBI + int(LpM * rpLN * rpW)

                    dRP.push(box.new(sBI + vpHO, pLST + (l + .1) * pSTP, eBI + vpHO, pLST + (l + .9) * pSTP, llC, bgcolor = llC, text = str.tostring(vpSRC == 'Money Flow' ? array.get(rpVST, l) : array.get(rpVST, l) * (pLST + (l + .5) * pSTP), format.volume) + ' ' + syminfo.currency + ' (' + str.tostring(math.abs(vtLV / rpVST.sum() * 100), '#.##') + '%)', text_halign =  text.align_left, text_color = chart.fg_color, text_size = vpS ))

                if spSH
                    sBI = (b[0]).i + rpLN * rpW
                    eBI = sBI - int(DpM * rpLN * rpW)

                    dRP.push(box.new(sBI + vpHO, pLST + (l + .1) * pSTP, eBI + vpHO, pLST + (l + .9) * pSTP, lsC, bgcolor = lsC, text = str.tostring(bbp, format.volume ) + (vpSRC == 'Money Flow' ? ' ' + syminfo.currency : '') + ' (' + str.tostring(math.abs(bbp / vtLV * 100), '#.##') + '%)', text_halign =  text.align_right, text_color = chart.fg_color, text_size = vpS ))

                if hmSH
                    dRP.push(box.new((b[rpLN]).i, pLST + (l + .0) * pSTP, (b[0]).i, pLST + (l + 1.) * pSTP, hmSRC == hmSO1 ? color.new(llC, hmTR) : lsC, bgcolor = hmSRC == hmSO1 ? color.new(llC, hmTR) : lsC))
